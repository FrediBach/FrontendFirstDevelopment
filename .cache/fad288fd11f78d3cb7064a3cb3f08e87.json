{"id":"index.html","dependencies":[{"name":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/package.json","includedInParent":true,"mtime":1531479550054},{"name":"./apple-icon-57x57.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/apple-icon-57x57.png"},{"name":"./apple-icon-60x60.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/apple-icon-60x60.png"},{"name":"./apple-icon-72x72.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/apple-icon-72x72.png"},{"name":"./apple-icon-76x76.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/apple-icon-76x76.png"},{"name":"./apple-icon-114x114.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/apple-icon-114x114.png"},{"name":"./apple-icon-120x120.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/apple-icon-120x120.png"},{"name":"./apple-icon-144x144.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/apple-icon-144x144.png"},{"name":"./apple-icon-152x152.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/apple-icon-152x152.png"},{"name":"./apple-icon-180x180.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/apple-icon-180x180.png"},{"name":"./android-icon-192x192.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/android-icon-192x192.png"},{"name":"./favicon-32x32.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/favicon-32x32.png"},{"name":"./favicon-96x96.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/favicon-96x96.png"},{"name":"./favicon-16x16.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/favicon-16x16.png"},{"name":"./manifest.json","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/manifest.json"},{"name":"./ms-icon-144x144.png","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/ms-icon-144x144.png"},{"name":"./main.css","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/main.css"},{"name":"./main.js","dynamic":true,"parent":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/index.html","resolved":"/Users/fredi.bach/Projects/github/frontendfirstdevelopment/main.js"}],"generated":{"html":"<!DOCTYPE html>\n<html lang=\"en\">\n\n<head>\n    <meta charset=\"utf-8\">\n    <title>Frontend First Development</title>\n\n    <link rel=\"apple-touch-icon\" sizes=\"57x57\" href=\"/28c241c495ae48f37830c04eb1f0ef84.png\">\n    <link rel=\"apple-touch-icon\" sizes=\"60x60\" href=\"/77734f315f1e55e317fb697fefd8a192.png\">\n    <link rel=\"apple-touch-icon\" sizes=\"72x72\" href=\"/57b0b815fc85b72fa1492a13a3ec3d65.png\">\n    <link rel=\"apple-touch-icon\" sizes=\"76x76\" href=\"/948c1710aedf143edc1e81e9d2680bfb.png\">\n    <link rel=\"apple-touch-icon\" sizes=\"114x114\" href=\"/2f21c232a53b044335f9b27b3595bd63.png\">\n    <link rel=\"apple-touch-icon\" sizes=\"120x120\" href=\"/54970208ef8a3efc9f44b9cc573d7dd0.png\">\n    <link rel=\"apple-touch-icon\" sizes=\"144x144\" href=\"/6993ec8bccdeeec1578b140682d2e7d7.png\">\n    <link rel=\"apple-touch-icon\" sizes=\"152x152\" href=\"/c4ba66bb04bbb9692480fc7f16e24be2.png\">\n    <link rel=\"apple-touch-icon\" sizes=\"180x180\" href=\"/e22fea377aa54a1e9e631dd16bf18315.png\">\n    <link rel=\"icon\" type=\"image/png\" sizes=\"192x192\" href=\"/3ae0f270c7fecda3df8c82f57ce111cb.png\">\n    <link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/b6e422872bc935cb82ce0bbf5630bc30.png\">\n    <link rel=\"icon\" type=\"image/png\" sizes=\"96x96\" href=\"/3f796bd971b13a1bf3c40a7b31e2a0af.png\">\n    <link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/f127e1b64d777d9420a2405805c3169f.png\">\n    <link rel=\"manifest\" href=\"/4b2bac5d2d9ea9cebe02173c702a00b3.js\">\n    <meta name=\"msapplication-TileColor\" content=\"#ffffff\">\n    <meta name=\"msapplication-TileImage\" content=\"/61a9d5d422e5f8d85ba6985744b67bfe.png\">\n    <meta name=\"theme-color\" content=\"#ffffff\">\n\n    <link rel=\"stylesheet\" href=\"/991a98a949bf7272bf71ef8387cf8cd0.css\">\n    <!--[if IE]>\n\t\t<script src=\"http://html5shiv.googlecode.com/svn/trunk/html5.js\"></script>\n\t<![endif]-->\n</head>\n\n<body>\n\n    <div class=\"dialine1\"></div>\n    <div class=\"dialine2\"></div>\n\n    <div class=\"logo\">FFD</div>\n\n    <ul class=\"menu\">\n        <li>\n            <a href=\"#about\">About</a>\n        </li>\n        <li>\n            <a href=\"#why\">Why</a>\n        </li>\n        <li>\n            <a href=\"#technologies\">Key technologies</a>\n        </li>\n        <li>\n            <a href=\"#workflow\">Workflow</a>\n        </li>\n        <li>\n            <a href=\"#status\">Status</a>\n        </li>\n        <li>\n            <a href=\"#community\">Community</a>\n        </li>\n    </ul>\n\n    <h1>Frontend First Development</h1>\n\n    <div class=\"container\">\n        <div class=\"title\">\n            <span>Frontend</span>\n            <br>&nbsp;&nbsp;\n            <span>First</span>\n            <br>&nbsp;&nbsp;&nbsp;&nbsp;\n            <span>Development\n                <span>\n        </span></span></div>\n    </div>\n\n    <article>\n        <h2>TL;DR</h2>\n        <p>Solve friction between backend and frontend with an API mocking server, GraphQL, automatic server side rendering\n            and a schema first headless CMS of your choice.</p>\n\n        <h2 id=\"about\">About</h2>\n\n        <p>Back in the day, web development was a lot less complex. Those days the backend basically was the frontend, today\n            the backend and frontend are two distinct and often rather complex entities.\n            <mark>Syncing frontend templates and assets with backend rendered markup is often anything else than straight forward.</mark>\n            Depending on the CMS driving your site, you get more or less container markup wrapping the data outputted by\n            different modules and either you overwrite a lot of server templates (if that is even possible!) or you adapt\n            your CSS (not always possible either with flex based layouts) to integrate your markup.</p>\n        <p>\n            <mark>But thankfully there’s finally a promising path out of this mess!</mark> By doing as much as possible on the\n            frontend, ideally component based so you can abstract complexity into smaller more focused pieces, and than render\n            the routes and markup with a server side rendering framework, you never again have to sync markup from different\n            sources. And by additionally mocking the API server, we can flexibly and much faster tinker with the project\n            till everything is perfect, without first implementing the feature on the backend, making us more responsive\n            and our clients happy.</p>\n        <p>Let’s be honest, letting the backend render markup was never a great idea anyway. Not only does it create the described\n            friction between frontend and backend, it also isn’t really the expertise of backend developers, especially when\n            it comes to things like accessibility and above the fold performance optimisations.\n            <mark>A frontend first development workflow can solve us all these problems</mark> and this place here will try to\n            do it’s best to point you in the right directions.</p>\n\n        <blockquote>A content management system is for managing content, not for content rendering!</blockquote>\n\n        <h2 id=\"why\">Why</h2>\n\n        <p>Let’s first have an overview why we actually need to move to a frontend first development workflow by comparing its\n            advantages and possible disadvantages.</p>\n\n        <h3>Advantages:</h3>\n\n        <ul>\n            <li>\n                <mark>Less friction between FE & BE:</mark> Because a headless CMS only manages contend and delivers it to the\n                frontend over ideally a GraphQL API, you never need to sync markup between frontend & backend and as GraphQL\n                APIs are auto documenting, you always know exactly what’s available to you as a frontend developer.\n            </li>\n            <li>\n                <mark>Enables tinkering:</mark> As you are mocking the API, changes can be implemented much faster than actually\n                building the backend service first. So fast actually, that you can do live tinkering together with the client,\n                right on the product.\n            </li>\n            <li>\n                <mark>Easier debugging:</mark> Moving most of the business logic to the frontend and having a strongly typed auto\n                documenting API makes it very clear where an error comes from. In 99% of all cases it will originate from\n                your frontend code and you can debug it at one single place. Strongly typed languages like TypeScript or\n                Reason ML or even Elm can tell you where bugs are even while you code.\n            </li>\n            <li>\n                <mark>Client friendly:</mark> Clients often don’t have the expertise to judge an abstract technical concept without\n                something they can interact with. By developing frontend first, clients can judge a feature as realistically\n                as possible before any backend is implemented, making sure that stakeholders involved make informed decisions.\n            </li>\n            <li>\n                <mark>More focused backends</mark> Frontend first enables the backend to focus and optimise the right thing. By\n                knowing exactly what the frontend queries are, for example with the help of Apollo Engine, they can add caching\n                layers exactly where needed and use the freed up time to optimise the content management forms, delivering\n                the best experience to clients.\n            </li>\n            <li>\n                <mark>Skill targeting</mark> Frontend developers are the experts on writing HTML5, accessibility, optimising above\n                the fold performance ... why should the backend developers ever render markup for them?\n            </li>\n            <li>\n                <mark>Focus on the right thing:</mark> With frontend first, you spend most of the development time where it counts,\n                the thing people see and interact with, and automate as much of the rest as possible.\n            </li>\n            <li>\n                <mark>Decouple backend implementation:</mark> As you are developing data structures frontend first, the backend is forced to develop the API service decoupled from the actual implementation details like the database table names, field names in that table or the attribute names of an external API. This is very good practice as it protects the API from changing after an implementation change, but is often not done because of the extra overhead in development.\n            </li>\n        </ul>\n\n        <h3>Possible disadvantages:</h3>\n\n        <ul>\n            <li>\n                <mark>Frontend developer maturity:</mark> Designing normalised data structures is traditionally a backend job,\n                so frontend developers need to acquire this skill first so they can perfectly mock API services. But looking\n                at what the frontend community achieved in recent years, I’m not at all worried that this will be a big issue.\n                It is no surprise that the frontend community made the Flux paradigm popular again in favour of MVC, solving\n                many issues of the past.\n            </li>\n            <li>\n                <mark>Works better with a serial workflow:</mark> Ideally, the backend starts to build the real GraphQL API right\n                after the frontend has implemented all features. While there are often external API integration tasks the\n                backend can focus in the meantime, it definitely can happen that the backend is blocked by the frontend,\n                waiting for an implementation. But to be honest, up till now, the frontend was often blocked by the backend\n                for the same reasons, so this is not exactly a new issue after all.\n            </li>\n        </ul>\n\n        <h2>Less friction between FE and BE</h2>\n\n        <p>Let’s have a closer look at one of the pros, one that creates a lot of issues with current workflows, to get a better\n            idea why frontend first is such a tempting idea.</p>\n\n        <h3>Usual developer workflow:</h3>\n\n        <p>\n            <b>Path 1:</b> <b class=\"step\">Information Architecture</b> <b class=\"arrow\">></b> <b class=\"step\">Technical Specification</b> <b class=\"arrow\">></b> <b class=\"step\">Backend / DB</b> <b class=\"arrow\">></b> <b class=\"step\">Frontend Integration</b></p>\n        <p>\n            <b>Path 2:</b> <b class=\"step\">Information Architecture</b> <b class=\"arrow\">></b> <b class=\"step\">Design</b> <b class=\"arrow\">></b> <b class=\"step\">Design System</b> <b class=\"arrow\">></b> <b class=\"step\">CSS / Component Framework</b> <b class=\"arrow\">></b> <b class=\"step\">Frontend Implementation</b></p>\n\n        <p>\n            <mark>This workflow creates friction when both paths meet!</mark>\n        </p>\n\n        <h3>Frontend First Workflow:</h3>\n\n        <p>\n            <b>One path:</b> <b class=\"step\">Information Architecture</b> <b class=\"arrow\">></b> <b class=\"step\">Design</b> <b class=\"arrow\">></b> <b class=\"step\">Design System</b> <b class=\"arrow\">></b> <b class=\"step\">Component Library</b> <b class=\"arrow\">></b> <b class=\"step\">API Mocking</b> <b class=\"arrow\">></b> <b class=\"step\">Frontend Implementation</b> <b class=\"arrow\">></b> <b class=\"step\">Backend (Services Integration, Admin Forms and DB)</b></p>\n\n        <p>\n            <mark>Only one development path, no friction!</mark>\n        </p>\n\n        <p>Information architecture and technical specification is mostly a first draft. Than changes happen after the client\n            can interact with the frontend or living style guide, while iterating till every stakeholder is happy. Without\n            a frontend first approach, this leads to friction everywhere. Even content creation is more and more frontend\n            first focused these days, just think of headlines that have to be limited to certain lengths to match the design\n            and use fitting word lengths to break nicely in the limited space designed for that element.</p>\n\n        <h2 id=\"technologies\">Key technologies</h2>\n\n        <p>Thanks to some key technologies of recent years like GraphQL and all the tooling around it, we are now pretty close\n            to make a truly frontend first workflow possible!</p>\n\n        <h3>API server mocking</h3>\n\n        <p>The first key technology is API server mocking. On a frontend first workflow, you want to start working before any\n            backend is set up. Traditionally we used hardcoded data and mocked JSON endpoints to mock our API endpoints,\n            but\n            <mark>these days it’s now possible to mock a whole REST or GraphQL server with just some sample data</mark>. These\n            kind of servers support all the CRUD operations (create, read, update and delete) and especially with GraphQL,\n            can feel like the real thing, but with almost no effort. This is very important, as you can create prototypes\n            that are\n            <mark>so close to the real thing, that your client can get a very realistic impression of the final product, without\n                ever having to first setup a backend CMS.</mark> The other important feature of this approach, is that you\n            can design your sample data so realistically, that you can test frontend edge cases, for example different content\n            lengths, right from the beginning. As you’re working with sample data, changes to your API are done in seconds,\n            even changing normally complicated stuff like relationships, becomes really easy.</p>\n\n        <blockquote>If you want to have super fast iterations on your API, there’s no way around an API mocking server.</blockquote>\n\n        <p>Let’s have a look at an example. The following sample data defines a blogging API where users have posts and posts\n            can have comments and comments can be replies to other comments.</p>\n\n        <script src=\"https://gist.github.com/FrediBach/ac09a0dc589d5c20570b2c64aa336d59.js\"></script>\n\n        <p></p>\n        <p>Of course in a real world app, you would add more realistic content (no lorem ipsum!) and more entries for each type\n            to make it more realistic.</p>\n\n        <p>However,\n            <mark>this small sample data file already defines quite a few features that would normally take quite a while to implement.</mark>\n            For example there are multiple relationships between types, like that each user can have posts and comments assigned\n            to him. Each post can have multiple comments and comments can reference another comment (replies). Some fields\n            are optional, for example “comment_id” on the comment type as a post can have no comments.</p>\n\n        <p>Further, if we have to add a new field to our schema, all we need to do is add that field to the sample data, for\n            example an email field on the user type:</p>\n\n        <script src=\"https://gist.github.com/FrediBach/258fdbcbadb696d0a917cf81adb459e9.js\"></script>\n\n        <p></p>\n        <p>Just restart the mocking server, and that’s it! Same thing for relationships, just add it to your sample data, restart\n            the mocking server and you’re done. It couldn’t be easier and faster (well, beside adding a watcher to the mocking\n            server so you don’t have to restart it after every single change), making it possible to\n            <mark>dynamically alter your backend without actually writing any backend code, making it possible to iterate fast\n                and even tinker live on the source together with your client!</mark>\n        </p>\n\n        <h4>API mocking server tools:</h4>\n\n        <ul>\n            <li>GraphQL:\n                <ul>\n                    <li>\n                        <b>JSON GraphQL Server</b> (using sample data)\n                        <span class=\"arrow\">\n                            <svg width=\"11px\" height=\"10px\" viewbox=\"0 0 11 10\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n                                <g id=\"right-arrow\">\n                                    <path d=\"M1.77635684e-14,5 L9,5\" id=\"rod\" stroke=\"#000000\" stroke-width=\"2\"></path>\n                                    <path d=\"M11,5 L6,0.5 L6,9.5 L11,5 Z\" id=\"point\" fill=\"#000000\"></path>\n                                </g>\n                            </svg>\n                        </span>\n                        <a href=\"https://github.com/marmelab/json-graphql-server\">https://github.com/marmelab/json-graphql-server</a>\n                    </li>\n                    <li>\n                        <b>EasyGraphQL Mock</b> (schema first mocking)\n                        <span class=\"arrow\">\n                            <svg width=\"11px\" height=\"10px\" viewbox=\"0 0 11 10\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n                                <g id=\"right-arrow\">\n                                    <path d=\"M1.77635684e-14,5 L9,5\" id=\"rod\" stroke=\"#000000\" stroke-width=\"2\"></path>\n                                    <path d=\"M11,5 L6,0.5 L6,9.5 L11,5 Z\" id=\"point\" fill=\"#000000\"></path>\n                                </g>\n                            </svg>\n                        </span>\n                        <a href=\"https://github.com/EasyGraphQL/easygraphql-mock\">https://github.com/EasyGraphQL/easygraphql-mock</a>\n                    </li>\n                    <li>\n                        <b>GarphQL Faker</b> (faking data based on directives)\n                        <span class=\"arrow\">\n                            <svg width=\"11px\" height=\"10px\" viewbox=\"0 0 11 10\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n                                <g id=\"right-arrow\">\n                                    <path d=\"M1.77635684e-14,5 L9,5\" id=\"rod\" stroke=\"#000000\" stroke-width=\"2\"></path>\n                                    <path d=\"M11,5 L6,0.5 L6,9.5 L11,5 Z\" id=\"point\" fill=\"#000000\"></path>\n                                </g>\n                            </svg>\n                        </span>\n                        <a href=\"https://github.com/APIs-guru/graphql-faker\">GitHub - APIs-guru/graphql-faker: 🎲 Mock or extend your GraphQL API with faked data. No coding required.</a>\n                    </li>\n                </ul>\n            </li>\n            <li>REST:\n                <ul>\n                    <li>\n                        <b>JSON Server</b>\n                        <span class=\"arrow\">\n                            <svg width=\"11px\" height=\"10px\" viewbox=\"0 0 11 10\" version=\"1.1\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">\n                                <g id=\"right-arrow\">\n                                    <path d=\"M1.77635684e-14,5 L9,5\" id=\"rod\" stroke=\"#000000\" stroke-width=\"2\"></path>\n                                    <path d=\"M11,5 L6,0.5 L6,9.5 L11,5 Z\" id=\"point\" fill=\"#000000\"></path>\n                                </g>\n                            </svg>\n                        </span>\n                        <a href=\"https://github.com/typicode/json-server\">GitHub - typicode/json-server: Get a full fake REST API with zero coding in less than 30 seconds\n                            (seriously)</a>\n                    </li>\n                </ul>\n            </li>\n        </ul>\n\n        <p>Our recommendation is of course to use the GraphQL variant, as it has multiple advantages like having just one very\n            flexible endpoint, no over and under fetching and auto documentation and autocomplete for all possible queries\n            and fields.</p>\n\n        <blockquote>GraphQL is the enabler of a true frontend first workflow!</blockquote>\n\n        <h3>GraphQL</h3>\n\n        <p>In a real world application, where performance counts, REST runs into problems pretty fast. What normally happens\n            on every project, is that you start implementing custom endpoints for pretty much everything, to prevent over\n            and under fetching and especially having to call multiple endpoints to get all the data you need. Thankfully\n            GraphQL solves all these problems.\n            <mark>Not having to write custom endpoints, makes the switch from a mocked API to the real thing extremely easy.</mark>\n            In most cases all you need to change is the url to the real API. Here is an example query for the sample data\n            posted above:</p>\n\n        <script src=\"https://gist.github.com/FrediBach/a6eacfd57889a0a5bda7374ef542c90e.js\"></script>\n\n        <p></p>\n        <p>With a REST API, this simple query could already end up in a maximum of 11 requests to the server as you would have\n            to do one extra request for each unique user, definitely not something you want to happen on a mobile connection!\n            That’s why in any realistic real world REST setup, you would create a custom endpoint for this case, but with\n            GraphQL that isn’t needed at all, allowing us to easily mock the API in a realistic way.</p>\n\n        <p>For consuming a GraphQL endpoint, I highly recommend Apollo. It hits a sweet spot between advanced features like\n            caching, optimistic UI, refetching etc. and ease of use and it’s where the community is at right now, so you\n            have nice documentation, tons of articles and a great community in case you run into problems. For very simple\n            APIs and frontends, Lokka can be a great alternative.</p>\n\n        <ul>\n            <li>\n                <b>Apollo:</b>\n                <a href=\"https://www.apollographql.com/\">Apollo GraphQL | Learn about the Apollo platform: Client, Engine, GraphQL servers, GraphQL support, and more.</a>\n            </li>\n            <li>\n                <b>Lokka:</b>\n                <a href=\"https://github.com/kadirahq/lokka\">https://github.com/kadirahq/lokka</a>\n            </li>\n        </ul>\n\n        <p>I would personally stick with Apollo, as it integrates nicely with server side rendering frameworks, as we’ll see\n            next and has it’s own caching proxy solution that you can use out of the box.</p>\n\n        <p>Now what if I need to integrate existing REST API endpoints? Maybe even external third party ones that I can’t port to GraphQL? With Apollo this is actually not a big issue.  \n            Thanks to Apollo Link Rest, you can easily use REST APIs together with GraphQL, in the same queries.</p>\n\n        <p>In case you don’t expect to use a CMS to manage the data, you can relatively easily setup a real GraphQL server.\n            Have a look at GraphQL engines, that make it possible to setup real database driven endpoints without too much\n            effort:</p>\n\n        <ul>\n            <li>\n                <b>Prisma:</b>\n                <a href=\"https://www.prisma.io/\">Prisma | Open-Source GraphQL ORM for GraphQL Servers</a>\n            </li>\n            <li>\n                <b>Hasura:</b>\n                <a href=\"https://hasura.io/\">GraphQL on Postgres | Hasura</a>\n            </li>\n            <li>\n                <b>PostGraphile</b>:\n                <a href=\"https://www.graphile.org/postgraphile/\">Graphile | Powerful, Extensible and Performant GraphQL APIs Rapidly</a>\n            </li>\n            <li>\n                <b>GrandStack:</b>\n                <a href=\"https://grandstack.io/\">GRANDstack · Build full stack graph applications with ease.</a>\n            </li>\n            <li>\n                <b>GraphQL Genie:</b>\n                <a href=\"https://github.com/genie-team/graphql-genie\">GraphQL Genie: Turn your GraphQL Schema into a fully featured GraphQL API with referential integrity, inverse updates and subscriptions</a>\n            </li>\n        </ul>\n\n        <p>Those are great options if you’re building all functionality by yourself (or your team), without a CMS managing your\n            data, but I wouldn’t do it initially, as it makes tinkering with your data quite a bit more involved.</p>\n\n        <h3>Headless CMS</h3>\n\n        <p>If you need a strong admin interface for content management, with approval workflows, the flexibility to integrate\n            other services and other enterprise requirements, you normally don’t build everything yourself from scratch,\n            you choose an enterprise level CMS that can handle all of that stuff already.\n            <mark>Sadly all the currently most popular CMS solutions on the market aren’t very well suited for a frontend first\n                workflow.</mark> But thankfully, new contenders are entering the market and are now realising the potential\n            of a schema based GraphQL API approach. Here’s a list of possible options:</p>\n\n        <ul>\n            <li>\n                <b>Contentful</b>:\n                <a href=\"https://www.contentful.com/\">Contentful: Content Infrastructure for Digital Teams</a>\n            </li>\n            <li>\n                <b>GraphCMS</b>:\n                <a href=\"https://graphcms.com/\">GraphCMS - The GraphQL Headless CMS</a>\n            </li>\n            <li>\n                <b>Mozaik</b>:\n                <a href=\"https://www.mozaik.io/\">Mozaik | Next generation headless GraphQL CMS</a>\n            </li>\n            <li>\n                <b>GENTICS Mesh</b>:\n                <a href=\"https://getmesh.io/\">Gentics Mesh - The open source headless CMS for developers</a>\n            </li>\n            <li>\n                <b>Canner:</b>\n                <a href=\"https://www.canner.io/\">Canner - Make CMS simple</a>\n            </li>\n            <li>\n                <b>Relax CMS:</b>\n                <a href=\"https://github.com/relax/relax\">GitHub - relax/relax: New generation CMS on top of React, Redux and GraphQL</a>\n            </li>\n            <li>\n                <b>Dato CMS:</b>\n                <a href=\"https://www.datocms.com/docs/content-delivery-api/querying/\">Querying the API - Content Delivery API - DatoCMS</a>\n            </li>\n        </ul>\n\n        <h3>Server Side Rendering</h3>\n\n        <p>When going frontend first, your CMS or API backend should only deliver the content and not render the frontend routes\n            and markup.\n            <mark>Now you could build everything as a single page app (SPA), but that has some serious disadvantages when it comes\n                to search engine optimisation (SEO)</mark>, a must for client projects. Thankfully we have great options\n            now that can solve this issue. The idea is that you build your frontend as you would in a SPA, but than have\n            a SSR framework that can extract the routes from your SPA and render them server side. Two options:</p>\n\n        <ul>\n            <li>\n                <b>Rouge:</b>\n                <a href=\"https://github.com/alidcastano/rogue.js\">GitHub - alidcastano/rogue.js: Rogue.js - a nearly invisible framework for creating server-rendered React\n                    applications</a>\n            </li>\n            <li>\n                <b>Reframe</b>:\n                <a href=\"https://github.com/reframejs/reframe\">GitHub - reframejs/reframe: Framework to create web apps.</a>\n            </li>\n            <li>\n                <b>Next.JS:</b>\n                <a href=\"https://nextjs.org/\">Next.js</a>\n            </li>\n            <li>\n                <b>After.js:</b>\n                <a href=\"https://github.com/jaredpalmer/after.js\">GitHub - jaredpalmer/after.js: Next.js-like framework for server-rendered React apps built with React Router\n                    4</a>\n            </li>\n            <li>\n                <b>Razzle:</b>\n                <a href=\"https://github.com/jaredpalmer/razzle\">GitHub - jaredpalmer/razzle: ✨ Create server-rendered universal JavaScript applications with no configuration</a>\n            </li>\n            <li>\n                <b>ReactQL:</b>\n                <a href=\"https://reactql.org/\">ReactQL: Modern stack for React+GraphQL</a>\n            </li>\n            <li>\n                <b>Nuxt (Vue based):</b>\n                <a href=\"https://nuxtjs.org/\">Nuxt.js - Universal Vue.js Applications</a>\n            </li>\n        </ul>\n\n        <p>The nice thing with Rogue is that it guesses your endpoints based on your React Router 4 setup. This way you can\n            build your project like a normal single page app, and\n            <mark>Rogue will build the server side rendering part automatically based on your apps routes</mark>, meaning you don’t\n            have to define anything twice and changes to your routes are immediately reflected to your server side routes.</p>\n\n        <blockquote>Server side rendering can be quite easy these days, you don’t have to come up with your own solutions.</blockquote>\n\n        <p>The other ones are less automatic, but can be great options, as well. Next.JS for example is quite battle tested\n            by now, so you probably won’t run into early adopter issues.</p>\n\n        <h2 id=\"workflow\">The Frontend First Development workflow</h2>\n\n        <p>As we had a look at the needed technologies now, let’s have a closer look at the frontend first workflow itself:</p>\n\n        <h3>1. Create realistic sample data for your project</h3>\n\n        <p>This is where everything starts. Initially build a simple sample data file that contains all the types, relationships\n            and has at least one entry per type that only contains the required fields, so that the mocking server can guess\n            the schema correctly. As the project goes on, start to add additional more realistic data. Work as long as possible\n            with sample data, so you can implement changes as fast as possible.</p>\n\n        <h3>2. Run the API mocking server</h3>\n\n        <p>You can now run the mocking server using your sample data locally using either GraphQL JSON Server or less recommended,\n            JSON Server for a REST API.</p>\n\n        <h3>3. Build your server side rendered app</h3>\n\n        <p>Setup your frontend with one of the server side rendering frameworks that can automate the server rendering part,\n            currently either Rogue or Reframe. Both frameworks make it possible to render your routes server side in a SEO\n            friendly way, without having to setup that part yourself, making it possible for you to focus on building your\n            frontend.</p>\n\n        <p>\n            <mark>For bigger projects, it is recommended to build your frontend on top of a living style guide, design system and\n                component library.</mark> Here are some libraries that can help you with that:</p>\n\n        <ul>\n            <li>\n                <b>Catalog:</b>\n                <a href=\"https://www.catalog.style/\">Catalog</a>\n            </li>\n            <li>\n                <b>Storybook:</b>\n                <a href=\"https://storybook.js.org/\">https://storybook.js.org/</a>\n            </li>\n            <li>\n                <b>React Styleguideist:</b>\n                <a href=\"https://react-styleguidist.js.org/\">React Styleguidist: isolated React component development environment with a living style guide</a>\n            </li>\n            <li>\n                <b>Styled System:</b>:\n                <a href=\"https://jxnblk.com/styled-system/\">Styled System</a>\n            </li>\n        </ul>\n\n        <h3>4. Iterate with the client till the frontend is perfect</h3>\n\n        <p>With the new powers and flexibility you get using a frontend first development workflow, use this chance to iterate\n            often and improve the product together with your client. An agile project setup is a must in a project like this.\n            While the one path workflow at first looks a lot like waterfall, your project actually profits most from an agile\n            workflow, where you iterate fast and often.</p>\n\n        <h3>5. Generate the schema for the backend and let them build the real API server</h3>\n\n        <p>Using your final sample data, you can now easily generate the GraphQL schema for the backend. From the same guy that\n            made JSON GraphQL Server, you can use this library to automatically generate the schema:\n            <a href=\"https://github.com/marmelab/graphql-schema-from-json\">GitHub - marmelab/graphql-schema-from-json: Guess a GraphQL schema from json data</a>\n        </p>\n\n        <h3>6. The backend generates (automatically or not) the admin interface based on the schema</h3>\n\n        <p>This is the point where you start implementing the CMS or the admin forms for the API server. Sadly on most current\n            CMS options, this isn’t an automatic process where you just import the schema and you’re done. This step still\n            involves clicking your backend types together, but things are starting to change, making this a one click process\n            like it should. If you’re running you project on a GraphQL engine, things are a little bit easier, but your entry\n            forms won’t be as client friendly as with a CMS solution.</p>\n\n        <h3>7. Connect the SPA to the real backend</h3>\n\n        <p>As soon as the backend is ready, switch your GraphQL endpoint in your SSR rendered app to the real thing. Deploy\n            and you’re done.</p>\n\n        <p>… and lastly …</p>\n\n        <h2 id=\"status\">Are we there yet?</h2>\n\n        <p>Almost.</p>\n\n        <p>There are still a few things that need to be improved before this approach can really take off. For example the GraphQL\n            API mocking server still has some missing features:</p>\n\n        <ul>\n            <li>Realistic error handling\n            </li>\n            <li>Query performance simulation by adding delays based on the complexity and depth of a query\n            </li>\n            <li>Sort, filter and pagination on sub queries\n            </li>\n            <li>Automatic id’s and support for non integer id’s\n            </li>\n            <li>Simulation of a auth permission system\n            </li>\n        </ul>\n\n        <p>On the server rendering side of things, many tools are still quite new and not extremely battle tested.</p>\n\n        <p>\n            <mark>But overall it’s a good time to start building frontend first and help the community improve the available tools\n                as much as you can.</mark>\n        </p>\n\n        <p>Looking at the available CMS solutions, it would be nice if you could import your sample data directly, or at least\n            the generated schema, for a real schema first experience.</p>\n\n        <p>Talking about schema first development. You may wonder why a sample data first and not schema first approach is described\n            here. Using schema directives to tell the server how to generate sample data could look like this:</p>\n\n        <script src=\"https://gist.github.com/FrediBach/297cb906f88c70f120c48bee8f497390.js\"></script>\n\n        <p></p>\n        <p>Or how GraphQL Faker does it:\n            <a href=\"https://github.com/APIs-guru/graphql-faker\">GitHub - APIs-guru/graphql-faker: 🎲 Mock or extend your GraphQL API with faked data. No coding required.</a>\n        </p>\n\n        <p>Personally I believe that you get much better results with realistically mocked data than with fake computer generated\n            fields. I do think GraphQL Faker has it’s uses, maybe even by combining it with a sample data server, but\n            <mark>working with clients and design driven development, realistic data is a must have.</mark>\n        </p>\n\n        <h2 id=\"community\">Frontend First Community</h2>\n\n        <p>If you like that idea of frontend first development, please join our new community on Reddit: <a href=\"https://www.reddit.com/r/FrontendFirst/\">r/FrontendFirst</a></p>\n\n        <p>And join the newsletter where we monthly post all the latest tools and articles about this topic.</p>\n\n        <!-- Begin MailChimp Signup Form -->\n        <link href=\"//cdn-images.mailchimp.com/embedcode/horizontal-slim-10_7.css\" rel=\"stylesheet\" type=\"text/css\">\n        <style type=\"text/css\">\n            #mc_embed_signup {\n                background: rgba(255,255,255,0.8);\n                border-radius: 3px;\n                clear: left;\n                font: 14px Helvetica, Arial, sans-serif;\n                width: 100%;\n                padding: 20px;\n            }\n        \n            /* Add your own MailChimp form style overrides in your site stylesheet or in this style block.\n        \t   We recommend moving this block and the preceding CSS link to the HEAD of your HTML file. */\n        </style>\n        <div id=\"mc_embed_signup\">\n            <form action=\"https://frontendfirstdevelopment.us18.list-manage.com/subscribe/post?u=8dab907200cb52013a1aaf830&amp;id=00d38f2abb\" method=\"post\" id=\"mc-embedded-subscribe-form\" name=\"mc-embedded-subscribe-form\" class=\"validate\" target=\"_blank\" novalidate=\"\">\n                <div id=\"mc_embed_signup_scroll\">\n                    <label for=\"mce-EMAIL\">Subscribe to our mailing list</label>\n                    <input type=\"email\" value=\"\" name=\"EMAIL\" class=\"email\" id=\"mce-EMAIL\" placeholder=\"email address\" required=\"\">\n                    <!-- real people should not fill this in and expect good things - do not remove this or risk form bot signups-->\n                    <div style=\"position: absolute; left: -5000px;\" aria-hidden=\"true\">\n                        <input type=\"text\" name=\"b_8dab907200cb52013a1aaf830_00d38f2abb\" tabindex=\"-1\" value=\"\">\n                    </div>\n                    <div class=\"clear\">\n                        <input type=\"submit\" value=\"Subscribe\" name=\"subscribe\" id=\"mc-embedded-subscribe\" class=\"button\">\n                    </div>\n                </div>\n            </form>\n        </div>\n        \n        <!--End mc_embed_signup-->\n\n        <p>Most importantly, help the community improve the tools, either by using them and post bug issues or feature request\n            or by directly getting involved in the development of these tools! :-)</p>\n\n    </article>\n\n    <footer>\n        (c) 2018 by Fredi Bach\n        <br>\n        <a href=\"https://www.unic.com/\">Unic AG</a>\n    </footer>\n\n    <script src=\"/895d365c5c0389430bfe2accb6f725d6.js\"></script>\n</body>\n\n</html>"},"hash":"766aaeae0d2a0e8f1705d97f37c7a19e","cacheData":{}}